# The DevOps 2.0 Toolkit
The reason I'm reading this book first is because it's practical. I was going to read `Continuous Delivery`, but I thought it'd be way better for me to actually get my hands dirty because I'm actually doing some CI/CD stuff at work and trying to make it better. I really want to make a good development environment for my team mates and let them develop way easier than ever. I want them to say: “Because of working with Robin, I could only focus on the business model and got the job done really fast and got to rest faster! Thanks and I would really love to work with an environment with Robin."
 Yup, an environment with me will establish a great development environment. Also, a great production environment :) Anyways, this book is actually a series and I think it'll be best for me to read them all since I think this author cares a hell lot about DevOps and the tools we need. If I get to know everything about DevOps, I want need to think about infrastructure stuff when I make my own products. I'll make my own development environment! Let's go!

## The DevOps Ideal
The author said he mostly failed on improving the systems that he tried to improve. I understand that too. Mostly, it'll be failures. And from those failures you'll learn, and you'll get to make a great success in some time when you really need it. If you have a lot of experience, it'll get much easier for you to this and that. It's pretty much hard for me to get everything right over here too. I really want to let everyone make their workflow better. Anyways, let's actually try to make the ideal, and really implement the ideal in real life. There'll be problems when you apply the ideals to the real world, but the thing is, you just have to keep on improving the disadvantages and you'll get to a point where everyone's pretty much in a great routine.

### Continuous Integration, Delivery, and Deployment
To make continuous integration happen, all we need to do is think about the developers who are actually making the product. But the thing is, I don't know how to think when we have backend developers and frontend developers. Of course integration tests can be done with databases and stuff, but how are we going to think about functional tests? Aren't API tests part of integration? It's actually the integration between the backend business logic and the database or whatever other API the server is calling. What about the frontend? So the frontend will have its own unit tests, integration tests. I'm not sure whether they need functional tests since they're integrating with the server. To make functional tests, we need to actually make a user story and that'll be actually the scope for frontend developers. Basically, the backend is integrating with a client, which can be abstracted since we don't need to know what is calling it. All we need to do is give the right data for that request. If you really want a functional test, we need to make test codes that involve both the frontend and the backend. It'll actually be a huge integration test, but that's what they call functional tests. Anyways, for that to happen, we need to have both the environments setup and it must be immutable and reproducible. Also, who are going to write tests for that kind of functional testing? Dunno if the DevOps team will do that stuff. But anyways, DevOps, is actually starting to be like a culture. 
 From delivery and deployment, the other people of other departments need to be inside the loop hole. We can't leave them out since we need to tell them how we're going to deploy our work to the real world. They must be ready, they must get ready, and all that stuff. So it's pretty much really cool how Instagram pulled off like 150 deployments each day. I want to make a company that can do that. Agility is a really important aspect. Anyways, let's improve the system, not just change it.

### Architecture
How to actually do something when the application is so monolithic that it’s hard to test and hard to split something up. You could do a big bang, or keep on changing the monolithic thing one by one. 
 So microservices was the answer to this thing but the problem was, there were a lot of other things that came with it. Deployment, which you had to deploy everything at once, libraries that coupled the services again, well, it was a disaster for the author. But the thing is, he wanted to solve the deployment problem first. For agility.

### Deployments
In the old days, we mostly had a lot of servers and those servers were like real pets. The system engineers cared for them. But now, they shouldn't be seen like precious things. They are just a one time thing. The thing that we have to consider special, is actually the CI/CD pipeline. So VMs and containers came out to make immutable infrastructure and actual deployments weren't just jar files or outputs like that, it was actually a running server that had everything in it. So we could just copy the infrastructure and make a testing, staging, development environment so easily. 

### Orchestration
So orchestration, I still really don't know the true meaning of this word. It's something like doing this and doing that. Puppet and Chef came out in this section. They' configuration management tools. So, we had a lot of the things that we did manually, are now programmable. We programmed all the configurations, and because of that, we were able to make immutable infrastructure. The problem was, there were too many, and it blew up into a pile of shit. Those are the pros and cons. Since Kubernetes is a container orchestration tool, now I start to get it. The servers that you need only need a Kubernetes client and just connect to the Kubernetes master. All they do is run the containers that the master coordinates. The resource manager should do all that stuff. I think `etcd` does that. 

### The Light at the End of the Deployment pipeline
Yep, it's all because of Docker. We finally got a way to actually make immutable infrastructure and make deploying infrastructure plausible. Let's take the red pill and see how this rabbit-hole goes. 

#reading/books
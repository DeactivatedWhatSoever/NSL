# 리눅스 커널 이야기


## 시스템 구성 정보 확인하기

### 커널 정보 확인하기

- 생각을 해보면, 내가 딱 컴퓨터에 ssh 해서 접속했을 때 알아야 할 정보들이 있다. 커널 버젼, 커널 파라미터, 그리고 무슨 하드웨어인지, CPU, RAM 관련된 정보들을 알아야 해당 장비들이 이 커널로 돌아가도 충분한지 잘 알 수 있다. 

	- 내 컴퓨터는 내가 알아야 하지! 어떤 녀석인지 아는 게 시작이다.

- uname: 커널 정보를 볼 수 있는 명령어.

	- 여러 가지 파라미터가 있는데, 다 보고 싶으면 -a 를 넣어주면 된다. 어떤 커널을 쓰는지 알려준다.

- dmesg: 커널 파라미터, 커널이 뜰 때에 대한 모든 드라이버 로깅, 기타 등등 대부분의 시작을 할 때의 대한 로깅을 한다고 함. 정보가 굉장히 많을 듯.

	- Mac 에서는 kernel 관련된 게 안 나오네 ㅠ.

	- dmesg뿐만 아니라 /proc 파일에 있는 애들을 통해서 알 수 있는 정보들이다. 하지만 역시 Mac 에서는 확인이 불가능하네 ... 나중에 검색해서 봐보자.

	- Crashkernel -> 여기 안에 커널 패닉이 일어났을 때 필요한 디버깅 정보를 담겨준다고 한다. 나중에 커널 패닉때문에 컴터가 이상해지거나 그러면 꼭 확인해봐야겠다. 끝까지 원인을 찾아서 해결해보자!

	- 이거 공부하니까 진짜 신나네 :) 하여간, intel_idle.max_cstate라는 게 있는데, 커널 파라미터다. CPU 코어가 일이 없을 때 잠들게 해주는 기능을 하는데, 서버 입장에서는 무조건 다 켜져있는 게 더 이득을 확률이 높다. 왜냐하면 트래픽이 갑자기 들어왔을 때 그거를 받아내기 용이해서다.

		- 사실 커널 파라미터는 이것 말고도 굉장히 많을테니, 또 뭐가 있는지 꼭 확인해보자.

		- 참고로 BIOS 에서 끄면 Intel Module 이 알아서 다시 켜준다는 현상이 있어서, 커널 파라미터로 아예 잡아버리면 완전히 꺼진다고 한다. 한 마디로 커널 파라미터가 가장 높은 설정으로 생각하면 될듯하다.

- 추가적으로 커널의 컴파일 옵션에 따라서 사용할 수 있는 기능이 다르다고 한다. 그래서 꼭 확인을 해봐야한다.

	- CONFIG_FUNCTION_TRACER=y 가 되야 커널 함수 레벨의 추적이 가능해진다.

### CPU 정보 확인하기

- dmidecode: 해당 명령어는 하드웨어의 정보를 확인할 수 있다. 메뉴얼을 보면 bios, system, baseboard, chassis, processor, memory,. Cache, connector, slot와 같은 것들이 있음. 

- CPU에 대한 정보를 알고 싶다면, bios, system, processor에 대해서 보면 된다. 

- 추가적으로 lscpu, cat /proc/cpuinfo 와 같은 명령어로 볼 수 있다.

	- lscpu는 NUMA에 대한 정보도 포함해서 보여준다.

- 모델명이 뭐고, 소캣이 몇 개 있고, 코어가 몇 개읹, 스레드가 몇 개 있는지, 기타 등등의 모든 정보들을 볼 수 있어야 한다.

### 메모리 정보 확인하기

- dmidecode -t memory를 통해서 정보를 확인할 수 있다.

- dmidecode -t memory | grep -I size 떄리면, No Module Installed 가 나온다면, 그 부분에는 메모리가 없다는 것이다.

- free -m을 통해서 얼마가 사용되고 있는지 알 수 있다. 그래서 free -m 의 합과 dmidecode -it memory 의 합이 같아야 제대로 인식되고 있다고 판단할 수 있다.

- 물론 이런거는 서버를 사기 이전에 모든거를 알게 되겠지만, 지금 나처럼 서버를 후에 알게 된 상황이라면 굉장히 유용한 정보다.

- Physical Memory Array: 한 CPU 소캣이 할당된 메모리 그룹 Memory Device: 실제로 꽂혀있는 메모리

### 디스크 정보 확인하기

- df: 기본적으로 이 명령어로 다 볼 수 있지만, 중요한 것은 진짜 디스크의 모든 정보를 볼 줄 알아야 한다는 것이다.

	- 우선은 컨트롤러가 어디 제조사인지 알아야하는데, 그 정보는 lsmod라는 명령어를 통해서 알 수 있다.

	- smartctrl: 이 명령어를 통해서 디스크의 자세한 정보들을 알 수 있다. 

	- Smartmoxntools -> This is the dude that I’m looking for.

- vda, hda, sda 에 대해서도 알아야 한다.

	- vda: 하이퍼바이저들이 쓰는 디스크 방식이다

	- hda: IDE 방식의 컨트롤러, 보통 개인용 컴퓨터에 들어간다.

	- sda: SCSI, SATA, SAS와 같은 하드 디스크들을 표시

### 네트워크 정보 확인하기

- lspci: 이 명령어를 통해서 Ethernet, 네트워크 카드에 대해서 알 수 있다. ether만 보고싶다면 grep -I ether 떄리면 된다.

- 전체적으로 커널 버젼, 펌웨어 버젼에 따라서 버그가 있는지, 약점이 있는지, 알 수 있어서, 이 모든것을 관리하기 위해서 알아놔야 한다고 본다.

	- 해당 제품들에 대한 news를 계속 알고 있고, 무언가가 터졌을 때 바로 펌웨어를 업데이트 한다던지, 그럴 수 있지 않을까 생각한다.

- ethtool: 해당 명령어를 통해서 ifconfig에 있는 네트워크 관련된 애들에 대한 자세한 정보를 얻을 수 있다.

	- -g: Ring Buffer에 대한 정보를 얻을 수 있다. 이는 네트워크 카드가 선으로부터 얻은 데이터의 버퍼 공간을 말한다. 이를 잘 튜닝함으로써 성능 최적화를 할 수 있다. Maximum과 Current의 숫자를 맞춰야 한다.

	- -k: 지금 사용중인 네트워크 카드의 성능 최적화 옵션을 볼 수 있다.

	- -i: 지금 사용중인 네트워크 카드의 커널 드라이버 버젼과 펌웨어 버젼을 알 수 있다. 역시나 문제가 생겼을 때 가장 먼저 봐야할 것! 내가 직접적으로 패치를 할 수 있는 상황이라면 상관 없지만, 기다려야 하는 상황이라면 버젼이라도 최대한 빨리 올려야한다고 생각.

	- 참고로 모두 대문자로 하게 되면, 해당 값을 바꿀 수 있게 해주는 옵션이다.

### 요약

- 1. Dmidecode 명령을 통해서 CPU, 메모리, BIOS등의 정보를 확인할 수 있다. 주로 사용되는 키워드는 bios, system, processor, memory, 4개의 키워드다.

- 2. CPU 정보는 /proc/cpuinfo 파일을 통해서도 확인할 수 있다.

- 3. Free 명령을 통해서 시스템에 설치된 메모리의 전체 크기를 알 수 있다.

- 4. 시스템에 마운트된 블록 디바이스의 정보는 df 명령을 통해서 확인할 수 있다. sda는 오래된 SCSI 방식의 디스크나 요즘에 나오는 SAS, SATA와 같은 하드디스크 타입의 인터페이스를 사용하는 장치, hda는 IDE 기반의 디스크, vda는 가상 하이퍼바이저 기반의 디스크가 마운트되어 있다는 것을 의미한다.

- 5. 네트워크 카드 정보는 ethtool 명령을 통해서 확인할 수 있다. 그 중에서도 -g, -k, -I 옵션을 가장 많이 사용한다.

- 6. ethtool 명령 중 -g 옵션으로 네트워크 카드에 설정된 Ring Buffer 의 최대 크기와 현재 크기를 확인할 수 있다.

- 7. ethtool 명령 중 -k 옵션으로 네트워크 카드의 부수적인 기능들을 확인할 수 있다.

- 8. ethtool 명령 중 -I 옵션으로 네트워크 카드가 사용 중인 커널 드라이버의 정보를 확인할 수 있다.

## top을 통해 살펴보는 프로세스 정보들

### 시스템의 상태 살피기

- 여기서는 대부분 전체적인 System usage와, 가장 중요한 프로세스들의 상태를 알아볼 수 있다. 그것도 top 명령어를 통해서! -b 옵션을 주면 조금 더 많은 정보를 준다고 한다.

- 일단 조금 더 생각을 해본다면, 서버가 얼마동안 떠있었는지, 메모리를 얼마나 사용하는지, CPU를 얼마나 사용하는지, 기타 등등 다 알 수 있다.

- 제일 중요한 것은 프로세스들의 중요도, 얼마나 자원을 먹는지 볼 수 있는 게 제일 중요한 목적이다.

### VIRT, RES, SHR ..?

- VIRT: Virtual memory. 해당 task에 할당된 가상 메모리의 양이다.

- RES: Resolved? Physical memory. 해당 task에 할당된 실제 메모리의 양이다. 아무래도 가상 메모리는 아직 완전히 할당된 게 아니어서 덜 중요하지만, 정말로 메모리를 얼마나 쓰는지는 여기서 결정된다.

- SHR: Shared Memory. 괜찮은 예시로 라이브러리를 생각할 수 있다. 어떠한 라이브러리들은 task들끼리 공유할 수 있다. 그런 애들을 task 마다 모두 참조해서 메모리 위에 올려놓으면 상당히 낭비일 것이다. (유닉스... 정말 똑똑하군!)

	- 뭔가 서로 겹치거나, 같이 사용한다는 것에 대한 탐지는 어떻게 할까? 그리고 막상 같은 버젼을 안 쓰면 어떻게 하지?

### VIRT와 RES 그리고 Memory Commit의 개념

- 일단은 COW(Copy On Write)와 같은 기능, 즉 프로세스 fork() 기능을 지원하려면 virtual memory + memory commit 개념이 있어야 한다. 만약 메모리가 필요한 대로 할당을 해버린다면, 물리 메모리가 다 찼을 때 fork() + exec()하는 것 조차 할 수 없는 상황이 된다. 정말 떠야 하는 녀석이 있는데, 어떻게든 떠야 하는데 못 띄우게 된다.

- 이게 바로 vm.memory_overcommit과 같은 커널 파라미터 덕분에 가능한 것이다. 그런데, virtual memory를 계산하는 방식은 여러 개다. 3 가지가 있다. 0,1,2의 값을 가진다. 0과 2는 메모리를 어떠한 식에 의해서 commit 하지만, 1번은 무조건 commit을 한다. 무조건 commit 하게 되면 메모리 누수가 있는 프로그램이나, 덩치가 큰 녀석이 실행되면 커널 패닉이 일어날 확률이 높다.

### 프로세스의 상태 보기

- PID를 다 쓰게 되면 죽는다! Sysctl -a | grep max_pid를 보면서 몇 개의 프로세스가 최대로 뜰 수 있는지 확인할 수 있다. 아무래도 더 많으면 많을수록 좋으면서, 정말로 컴퓨터가 버틸 수있는 리소스가 있는지 확인하는것도 중요하다.

- 프로세스 상태는 S -> 아무래도 State 겠지? 여러개가 있다!

	- D: uninterruptible sleep = 디스크 혹은 I/O를 대기하고 있는 프로세스들. Run Queue -> Wait Queue에서 대기한다.

	- R: 실행중인 프로세스 = 이녀석은 ... CPU와 메모리를 잡아먹는다!

	- S: sleeping: D와의 차이점: 요청한 리소스를 즉시 사용할 수 있다. sleep() 콜하면 이 상태로 빠지는듯. 

	- T: traced or stopped, strike 등으로 프로세스의 시스템 콜을 추적하고 있는 상태. 보통은 볼 수 없다.

	- Z: zombie process! 부모가 죽으면 해당 상태로 빠진다

		- 여기서 PID 문제가 중요해짐. 리소스도 안 잡아먹지만, PID를 잡아먹기에 문제가 됨.  왜 모든 프로세스는 만들 때 fork()를 하는가? 새로 만드는거는 없는건가? 그냥 무조건 fork()인건가?

### 프로세스의 우선순위

- Tasks -> Run Queue -> Scheduler -> Dispatcher -> CPU  Where is Wait Queue?

- PR: Priority. 프로세스의 우선순위를 뜻한다.

- NI: Nice value. 프로세스가 얼마나 ‘착한’지를 알려주는 값이다. Nice value가 -면, 나쁜 녀석이고, +면 착한 녀석이어서 그만큼 우선순위에서 밀리거나, 올라오거나 할 수 있다.

	- Nice Value 가 아무리 높아도, CPU Core 의 숫자가 꽉 차지 않는 이상 무조건 일찍 끝나지 않는다. 하지만 CPU Core 가 꽉 찬 상태라면, 해당 프로그램은 무조건 더 일찍 끝난다.

- RT(Real Time) Scheduler vs CFS(Completely Fair Scheduler)

	- 커널에서도 리얼 타임으로 끝내야 하는 프로세스들이 있다. 아무래도 우선순위가 가장 높지 않을까 싶다. User 로서는 어떻게 건들일 수 없는! 메모리가 부족하지 않게 하기 위해서는 가끔은 권한을 위임해야 한다. 

### 요약

## Load Average와 시스템 부하

### Load Average의 정의

### Load Average 계산 과정

### CPU Bound vs I/O Bound

### vmstat으로 부하의 정체 확인하기

### Load Average가 시스템에 끼치는 영향

### Case Study - OS 버전과 Load Average

### 요약

## free 명령이 숨기고 있는 것들

### 메모리 사용량 확인하기

### buffers와 cached 영역

### /proc/meminfo 읽기

### Slab 메모리 영역

### Case Study - Slab 메모리 누수

### 요약

## Swap, 메모리 증설의 포인트

### Swap 영역

### 버디 시스템

### 메모리 재할당 과정

### Vm.swappiness와 vm.vfs_cache_pressure

### 메모리 증설의 포인트

### Case Study - gdb를 이용해서 메모리 누수 잡기

### 요약

## NUMA, 메모리 관리의 새로운 세계

### NUMA 아키텍처

### 리눅스에서의 NUMA 확인

### 메모리 할당 정책별 특징

### Nomad를 이용한 메모리 할당 관리

### Vm.zone_reclaim_mode 커널 파라미터

### NUMA 아키텍처의 메모리 할당 정책과 워크로드

### 요약

## TIME_WAIT 소켓이 서비스에 미치는 영향

### TCP 통신 과정

### TIME_WAIT 소켓의 문제점

### 클라이언트에서의 TIM_WAIT

### Net.ipv4.tcp_tw_reuse

### ConnectionPool 방식 사용하기

### 서버 입장에서의 TIME_WAIT 소켓

### net.ipv4.tcp_tw_recycle

### Keepalive 사용하기

### TIME_WAIT 상태의 존재 이유

### Case Study - nginx upstream에서 발생하는 TIME_WAIT

### 요약

## TCP Keepalive를 이용한 세션 유지

### TCP Keepalive란

### TCP Keepalive의 파라미터들

### TCP Keepalive와 좀비 커넥션

### TCP Keepalive와 HTTP Keepalive

### Case Study - MQ 서버와 로드 밸런서

### 요약

## TCP 재전송과 타임아웃

### TCP 재전송과 RTO

### 재전송을 결정하는 커널 파라미터

### 재전송 추적하기

### RTO_MIN 값 변경하기

### 애플리케이션 타임아웃

### 요약

## dirty page가 I/O에 끼치는 영향

### dirty page란

### dirty page 관련 커널 파라미터

### 백그라운드 동기화

### dirty page 설정과 I/O 패턴

### 요약

## I/O 작업이 지나가는 관문, I/O 스케줄러

### I/O 스케줄러의 필요성

### I/O 스케줄러 설정

### Cfq I/O 스케줄러

### Deadline I/O 스케줄러

### Noop I/O 스케줄러

### cfq와 deadline의 성능 테스트

### I/O 워크로드 살펴보기

### 요약

## 애플리케이션 성능 측정과 튜닝

### 애플리케이션 만들기

### 성능 테스트 시작

### CPU 성능 최적화하기

### 네트워크 소켓 최적화하기

### nginx를 통해 reverse proxy 설정하기

### 요약

## 커널 디버깅을 위한 커널 컴파일

### 커널 소스 컴파일하기

### printk() 함수 추가하기

### printk() 함수로 Load Average 계산 과정 살펴보기

### 요약

## strace를 통한 애플리케이션 분석

### strace의 기본 사용법

### Hostname 명령 분석하기

### 요약

## tcmpdump와 와이어샤크를 통한 TCP 패킷 분석

### tcpdump의 사용법

### 와이어샤크 사용법

### 요약

